\documentclass[12pt,a4paper]{article}

\usepackage{todonotes}

\newenvironment{mathprooftree}
  {\varwidth{.9\textwidth}\centering\leavevmode}
  {\DisplayProof\endvarwidth}

\usepackage{graphicx}
\graphicspath{{./imgs/}}
\usepackage{amsmath,amssymb,amsfonts,varwidth}
\usepackage{enumitem}
\usepackage{bussproofs}
\EnableBpAbbreviations{}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,automata,petri,positioning,calc,fit}
\tikzset{
    ASG/.style={
        circle,
        draw=black,
        minimum size=6mm,
    },
    lts/.style={
        circle,
        draw=black,
        fill=blue!6,
        minimum size=8mm,
   },
    prod/.style={
        ellipse,
        draw=black,
        fill=yellow!20,
        minimum size=8mm,
   },
    every edge/.style={
        draw,
        ->,>=stealth',
        auto,
        semithick
    },
    initial text = {},
    node distance=2.5cm,
    double distance=2pt,
}

% put your student ID here instead of 1234567

\newcommand{\thestudentid}{1803086}

% put the number of the question you are answering here, instead of 0

\newcommand{\theexam}{Programming Language Principals, Design and Implementation (Extended)}
\newcommand{\shorttheexam}{PLPDI (Extended)}

\author{ID \thestudentid}
\title{Exam for \theexam}
\date{}

\usepackage{cmbright}
\usepackage{fullpage}
\usepackage{fancyhdr}

\pagestyle{fancyplain}
\setlength{\headheight}{15pt}
\lhead{\fancyplain{ID \thestudentid}{ID \thestudentid}}
\rhead{\fancyplain{\theexam}{\theexam}}
\lfoot{\fancyplain{ID \thestudentid}{ID \thestudentid}}
\rfoot{\fancyplain{\shorttheexam}{\shorttheexam}}

\usepackage{hyperref}
\newcounter{question}\setcounter{question}{1}
\newenvironment{question}{%
\subsection*{Question \arabic{question}}}%
{\stepcounter{question}}

\begin{document}


\maketitle
After inserting your student ID and the module title in
the preamble, write your answers below.

\begin{question}

  \begin{enumerate}[label= (\alph*)]
    \item
          \[
            M = \lambda f: \mathbb{B} \rightarrow \mathbb{B}. \lambda g: \mathbb{B}\rightarrow \mathbb{B}. \lambda x: \mathbb{B}. \lambda y: \mathbb{B}. \texttt{if } x \texttt{ then } f y \texttt{ else } g y
          \]
          \begin{enumerate}[label= (\roman*)]
            \item
                  \begin{prooftree}

                    \AXC{}
                    \RL{\texttt{VAR} }
                    \UIC{$\Gamma \vdash x : \mathbb{B}$}


                    \AXC{}
                    \RL{\texttt{VAR} }
                    \UIC{$\Gamma \vdash f : \mathbb{B}\rightarrow \mathbb{B}$}

                    \AXC{}
                    \RL{\texttt{VAR} }
                    \UIC{$\Gamma \vdash y : \mathbb{B}$}

                    \RL{\texttt{APP} }
                    \BIC{$\Gamma \vdash fy : \mathbb{B}$}

                    \AXC{$\Pi_{1}$}

                    \TIC{$\Gamma, y:\mathbb{B} \vdash \texttt{if } x \texttt{ then } f y \texttt{ else } g y: \mathbb{B}$}
                    \RL{\texttt{ABS} }
                    \UIC{$\Gamma, x:\mathbb{B} \vdash \lambda y: \mathbb{B}. \texttt{if } x \texttt{ then } f y \texttt{ else } g y: \mathbb{B}\rightarrow \mathbb{B}$}
                    \RL{\texttt{ABS} }
                    \UIC{$\Gamma,g:\mathbb{B}\rightarrow \mathbb{B} \vdash \lambda x: \mathbb{B}. \lambda y: \mathbb{B}. \texttt{if } x \texttt{ then } f y \texttt{ else } g y: \mathbb{B}\rightarrow \mathbb{B}\rightarrow \mathbb{B}$}
                    \RL{\texttt{ABS} }
                    \UIC{$f: \mathbb{B} \rightarrow \mathbb{B} \vdash  M_{1} :(\mathbb{B} \rightarrow \mathbb{B}) \rightarrow \mathbb{B} \rightarrow \mathbb{B} \rightarrow \mathbb{B} $}
                    \RL{\texttt{ABS}}
                    \UIC{$ \{  \} \vdash M : (\mathbb{B}\rightarrow \mathbb{B}) \rightarrow (\mathbb{B} \rightarrow \mathbb{B}) \rightarrow \mathbb{B} \rightarrow \mathbb{B} \rightarrow \mathbb{B}$}
                  \end{prooftree}

                  Where:

                  \begin{itemize}
                    \item $M_{1} = \lambda g: \mathbb{B}\rightarrow \mathbb{B}. \lambda x: \mathbb{B}. \lambda y: \mathbb{B}. \texttt{if } x \texttt{ then } f y \texttt{ else } g y$
                    \item $\Pi_{1}=$
                          \begin{prooftree}
                            \AXC{}
                            \RL{\texttt{VAR} }
                            \UIC{$\Gamma \vdash g: \mathbb{B}\rightarrow \mathbb{B}$}

                            \AXC{}
                            \RL{\texttt{VAR} }
                            \UIC{$\Gamma \vdash y:\mathbb{B}$}

                            \RL{\texttt{APP} }
                            \BIC{$\Gamma \vdash gy : \mathbb{B}$}
                          \end{prooftree}
                  \end{itemize}

            \item To produce the exclusive function from $M$ we can define the first order parameters $F$ and $G$ as follows:
                  \[
                    F = \lambda y:\mathbb{B}. \texttt{if } y \texttt{ then false}  \texttt{ else true}  : \mathbb{B}\rightarrow \mathbb{B}
                  \]
                  \[
                    G = \lambda y: \mathbb{B}. \texttt{if } y \texttt{ then true}  \texttt{ else false} : \mathbb{B}\rightarrow \mathbb{B}
                  \]
                  Alternatively, $G$ can simply be defined as the boolean identity function $\lambda y: \mathbb{B}. y : \mathbb{B}\rightarrow \mathbb{B}$. This is the definition I will use in later parts of the question.

            \item
                  The fact that this expression is well-typed under the Simply-typed $\lambda$-Calculus means \todo[inline]{Finish this question}
            \item

                  \begin{equation}
                    \begin{mathprooftree}
                      \AXC{}
                      \RL{$\beta$}
                      \UIC{$\lambda f: \mathbb{B}\rightarrow \mathbb{B}. M_{1} F \rightarrow_{v} \lambda g: \mathbb{B}\rightarrow \mathbb{B} \lambda x:\mathbb{B} \texttt{if } x \texttt{ then } Fy \texttt{ else } gy $}
                      \RL{$\texttt{CTX} _{\bullet G}$}
                      \UIC{\stackanchor{$\lambda f: \mathbb{B}\rightarrow \mathbb{B}.M_{1} F G \rightarrow_{v}$}{$(\lambda g: \mathbb{B}\rightarrow \mathbb{B} \lambda x:\mathbb{B} \texttt{if } x \texttt{ then } Fy \texttt{ else } gy)G $}}
                      \RL{$\texttt{CTX}_{(\bullet)\texttt{false } \texttt{true } }$}
                      \UIC{\stackanchor{$(M F G) \texttt{false } \texttt{true }  \rightarrow_{v}$}{$((\lambda g: \mathbb{B}\rightarrow \mathbb{B} \lambda x:\mathbb{B} \texttt{if } x \texttt{ then } Fy \texttt{ else } gy )G) \texttt{false } \texttt{true }$}}
                    \end{mathprooftree}
                  \end{equation}

                  \begin{equation}
                    \begin{mathprooftree}
                      \AXC{}
                      \RL{$\beta$}
                      \UIC{\stackanchor{$(\lambda g: \mathbb{B}\rightarrow \mathbb{B} \lambda x:\mathbb{B} \texttt{if } x \texttt{ then } Fy \texttt{ else } gy )G \rightarrow_{v} $}{$\lambda x:\mathbb{B}.\lambda y:\mathbb{B}. \texttt{if } x \texttt{ then } Fy \texttt{ else } G y $}}
                      \RL{$\texttt{CTX} _{(\bullet) \texttt{false } \texttt{true } }$}
                      \UIC{\stackanchor{$((\lambda g: \mathbb{B}\rightarrow \mathbb{B} \lambda x:\mathbb{B} \texttt{if } x \texttt{ then } Fy \texttt{ else } gy )G) \texttt{false } \texttt{true } \rightarrow_{v} $}{$(\lambda x:\mathbb{B}.\lambda y:\mathbb{B}. \texttt{if } x \texttt{ then } Fy \texttt{ else } G y) \texttt{false } \texttt{true }  $}}
                    \end{mathprooftree}
                  \end{equation}

                  \begin{equation}
                    \begin{mathprooftree}
                      \AXC{}
                      \RL{$\beta$}
                      \UIC{\stackanchor{$(\lambda x:\mathbb{B}.\lambda y:\mathbb{B}. \texttt{if } x \texttt{ then } Fy \texttt{ else } G y) \texttt{false } \rightarrow_{v}$}{$\lambda y:\mathbb{B} \texttt{if } \texttt{false}  \texttt{ then } F y \texttt{ else } G y $}}
                      \RL{$\texttt{CTX} _{\bullet \texttt{true } }$}
                      \UIC{\stackanchor{$(\lambda x:\mathbb{B}.\lambda y:\mathbb{B}. \texttt{if } x \texttt{ then } Fy \texttt{ else } gy) \texttt{false } \texttt{true } \rightarrow_{v}  $}{$(\lambda y:\mathbb{B} \texttt{if } \texttt{false}  \texttt{ then } F y \texttt{ else } G y) \texttt{true }  $}}
                    \end{mathprooftree}
                  \end{equation}

                  \begin{equation}
                    \begin{mathprooftree}
                      \AXC{}
                      \RL{$\beta$}
                      \UIC{\stackanchor{$(\lambda y:\mathbb{B} \texttt{if } \texttt{false}  \texttt{ then } F y \texttt{ else } G y) \texttt{true } \rightarrow_{v}$}{$\texttt{if } \texttt{false }  \texttt{ then } F \texttt{true }  \texttt{ else } G \texttt{true }    $}}
                    \end{mathprooftree}
                  \end{equation}

                  \begin{equation}
                    \begin{mathprooftree}
                      \AXC{}
                      \RL{\texttt{IteF} }
                      \UIC{$\texttt{if } \texttt{false }  \texttt{ then } F \texttt{true }  \texttt{ else } G \texttt{true }  \rightarrow_{v} G \texttt{true }   $}
                    \end{mathprooftree}
                  \end{equation}

                  \begin{equation}
                    \begin{mathprooftree}
                      \AXC{}
                      \RL{$\beta$}
                      \UIC{$(\lambda y:\mathbb{B}.y) \texttt{true } \rightarrow_{v} \texttt{true } $}
                    \end{mathprooftree}
                  \end{equation}
                  Where:
                  \begin{itemize}
                    \item $M_{1}$ is as defined the same as above.
                  \end{itemize}

                  $ \texttt{true } \in V$, $\therefore$ $(MFG) \texttt{false } \texttt{true } $ computes to a value.
          \end{enumerate}
    \item
        \[
        \texttt{Stack } = \forall \alpha.( \mathbb{N} \rightarrow \alpha \rightarrow \alpha ) \rightarrow \alpha \rightarrow \alpha
        \]
          \begin{enumerate}[label= (\roman*)]
            \item
                  \[
                  \lambda \alpha.\lambda f: \mathbb{N} \rightarrow \alpha \rightarrow \alpha .\lambda x:\alpha .f 0(f 0 (f 1 x))
                  \]
            \item
                  \[
                  \texttt{peek} = \lambda d:\mathbb{N} .\lambda s: \texttt{Stack} .s \{ \mathbb{N} \rightarrow \mathbb{N} \} G I d
                  \]
                  Where:
                  \begin{itemize}
                    \item $G = \lambda n: \mathbb{N} .\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x: \mathbb{N}. g n$
                    \item $I = \lambda x: \mathbb{N} .x$
                  \end{itemize}

                  \begin{prooftree}

                    \AXC{$\Pi_{1}$}

                    \AXC{$\Pi_{2}$}

                    \RL{\texttt{APP} }
                    \BIC{$\Gamma \vdash s \{ \mathbb{N} \rightarrow \mathbb{N}  \} G : (\mathbb{N} \rightarrow \mathbb{N} ) \rightarrow (\mathbb{N} \rightarrow \mathbb{N} )$}

                    \AXC{}
                    \RL{\texttt{VAR} }
                    \UIC{$\Gamma, x : \mathbb{N} \vdash x : \mathbb{N} $}
                    \RL{\texttt{ABS} }
                    \UIC{$\Gamma \vdash I : \mathbb{N} \rightarrow \mathbb{N} $}

                    \RL{\texttt{APP} }
                    \BIC{$\Gamma \vdash ((s \{ \mathbb{N} \rightarrow  \mathbb{N} \}G )I) : \mathbb{N} \rightarrow \mathbb{N}$}

                    \AXC{}
                    \RL{\texttt{VAR} }
                    \UIC{$\Gamma \vdash d : \mathbb{N} $}

                    \RL{\texttt{APP} }
                    \BIC{$\Gamma,s:\texttt{Stack} \vdash ((s \{ \mathbb{N} \rightarrow \mathbb{N} \} G) I) d : \mathbb{N} \rightarrow \texttt{Stack} \rightarrow \mathbb{N} : \mathbb{N}  $}
                    \RL{\texttt{ABS} }
                    \UIC{$d:\mathbb{N} \vdash \lambda s: \texttt{Stack} .s \{ \mathbb{N} \rightarrow \mathbb{N} \} G I d : \mathbb{N} \rightarrow \texttt{Stack} \rightarrow \mathbb{N} : \texttt{Stack} \rightarrow \mathbb{N}  $}
                    \RL{\texttt{ABS} }
                    \UIC{$ \{  \} \vdash \lambda d: \mathbb{N} .\lambda s: \texttt{Stack} .s \{ \mathbb{N} \rightarrow \mathbb{N} \} G I d : \mathbb{N} \rightarrow \texttt{Stack} \rightarrow \mathbb{N}  $}
                  \end{prooftree}


                  Where:
                  \begin{itemize}
                    \item $\Pi_{1}=$
                          \begin{prooftree}
                            \AXC{}
                            \RL{\texttt{VAR} }
                            \UIC{$\Gamma \vdash s: \texttt{State} $}
                            \RL{\texttt{TAPP} }
                            \UIC{$\Gamma \vdash s \{ \mathbb{N} \rightarrow \mathbb{N}  \} : ( \mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N} ) \rightarrow (\mathbb{N} \rightarrow \mathbb{N} ) ) \rightarrow (\mathbb{N} \rightarrow \mathbb{N} ) \rightarrow (\mathbb{N} \rightarrow \mathbb{N} )$}
                          \end{prooftree}
                    \item $\Pi_{2}=$
                          \begin{prooftree}
                            \AXC{}
                            \RL{\texttt{VAR} }
                            \UIC{$\Gamma \vdash g : \mathbb{N} \rightarrow \mathbb{N} $}

                            \AXC{}
                            \RL{\texttt{VAR} }
                            \UIC{$\Gamma \vdash n : \mathbb{N} $}

                            \RL{\texttt{APP} }
                            \BIC{$\Gamma,x:\mathbb{N} \vdash gn : \mathbb{N} $}
                            \RL{\texttt{ABS} }
                            \UIC{$\Gamma, g: \mathbb{N} \rightarrow \mathbb{N} \vdash \lambda x: \mathbb{N}. gn : \mathbb{N} \rightarrow \mathbb{N} $}
                            \RL{\texttt{ABS} }
                            \UIC{$\Gamma, n : \mathbb{N} \vdash \lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} . gn : (\mathbb{N} \rightarrow \mathbb{N} ) \rightarrow \mathbb{N} \rightarrow \mathbb{N} $}
                            \RL{\texttt{ABS} }
                            \UIC{$\Gamma \vdash G : \mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N} ) \rightarrow \mathbb{N} \rightarrow \mathbb{N} $}
                          \end{prooftree}
                  \end{itemize}
            \item
                  Prove:
                  \[
                  \texttt{peek } d s_{2} \rightarrow_{v}^{*} m
                  \]

                    \begin{prooftree}
                      \AXC{}
                      \RL{$\beta$}
                      \UIC{$(\lambda d:\mathbb{N} .\lambda s: \texttt{Stack} .s \{ \mathbb{N} \rightarrow \mathbb{N}  \} GId )d \rightarrow_{v} \lambda s: \texttt{Stack}.s \{ \mathbb{N} \rightarrow \mathbb{N}  \} GId $ }
                      \RL{$\texttt{CTX}_{\bullet s_{2}}$}
                      \UIC{$\texttt{peek } d s_{2} \rightarrow_{v} (\lambda s: \texttt{Stack}. s \{ \mathbb{N} \rightarrow \mathbb{N}  \} G I d )s_{2} $}
                    \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda s: \texttt{Stack} .s \{ \mathbb{N} \rightarrow \mathbb{N}  \} GId)s_{2} \rightarrow_{v} s_{2} \{ \mathbb{N} \rightarrow \mathbb{N}  \} GId $}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$T_{\beta}$}
                    \UIC{\stackanchor{$\lambda \alpha . \lambda f: \mathbb{N} \rightarrow \alpha \rightarrow \alpha . \lambda x: \alpha . f n ( f m x ) \{ \mathbb{N} \rightarrow \mathbb{N}  \} \rightarrow_{v}  $}{$\lambda f: \mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N} )\rightarrow (\mathbb{N} \rightarrow \mathbb{N} ). \lambda x: (\mathbb{N} \rightarrow \mathbb{N} ). f n (f m x)$}}
                    \RL{$\texttt{CTX} _{(\bullet G)I)d}$}
                    \UIC{\stackanchor{$((s_{2} \{ \mathbb{N} \rightarrow \mathbb{N}  \} G)I)d \rightarrow_{v}$}{$ (((\lambda f: \mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N}) \rightarrow (\mathbb{N} \rightarrow \mathbb{N} ). \lambda x: \mathbb{N} \rightarrow \mathbb{N} . f n (f m x))G)I)d $}}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{\stackanchor{$(\lambda f: \mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N} )\rightarrow (\mathbb{N} \rightarrow \mathbb{N} ). \lambda x: \mathbb{N} \rightarrow \mathbb{N}. f n ( f m x))G \rightarrow_{v} $}{$\lambda x:\mathbb{N} \rightarrow \mathbb{N} . Gn(Gmx)$}}
                    \RL{$\texttt{CTX} _{((\bullet)I)d}$}
                    \UIC{\stackanchor{$ (((\lambda f: \mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N}) \rightarrow (\mathbb{N} \rightarrow \mathbb{N} ). \lambda x: \mathbb{N} \rightarrow \mathbb{N} . f n (f m x))G)I)d \rightarrow_{v} $}{$((\lambda x: \mathbb{N} \rightarrow \mathbb{N}. Gn(Gmx))I)d$}}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda x:\mathbb{N} \rightarrow \mathbb{N} . Gn(Gmx))I \rightarrow_{v} Gn(GmI)$}
                    \RL{$\texttt{CTX} _{(\bullet)d}$}
                    \UIC{$((\lambda x: \mathbb{N} \rightarrow \mathbb{N}. Gn(Gmx))I)d \rightarrow_{v} (Gn(GmI)d)$}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda n: \mathbb{N} . \lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x: \mathbb{N} . gn)n \rightarrow_{v} \lambda g: \mathbb{N} \rightarrow \mathbb{N} .\lambda x: \mathbb{N} . gn$}
                    \RL{$\texttt{CTX} _{(\bullet(GmI))d}$}
                    \UIC{$(Gn(GmI)d) \rightarrow_{v} ((\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} .gn)(GmI))d$}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda n: \mathbb{N} \lambda g: \mathbb{N} \rightarrow \mathbb{N} \lambda x: \mathbb{N} .gn)m \rightarrow_{v} \lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x: \mathbb{N} .gm$}
                    \RL{$\texttt{CTX}_{((\lambda g: \mathbb{N} \rightarrow \mathbb{N} .\lambda x:\mathbb{N} .gn)(\bullet I))d} $}
                    \UIC{\stackanchor{$((\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} . gn)(GmI))d \rightarrow_{v}  $}{$((\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} .gn)((\lambda g:\mathbb{N} \rightarrow \mathbb{N} .\lambda x:\mathbb{N} .gm)I))d$}}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda g: \mathbb{N} \rightarrow \mathbb{N} .\lambda x:\mathbb{N} .gm)I \rightarrow_{v} \lambda x:\mathbb{N} . Im$}
                    \RL{$\texttt{CTX}_{((\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} .gn)(\bullet))d} $}
                    \UIC{\stackanchor{$((\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} .gn)((\lambda g:\mathbb{N} \rightarrow \mathbb{N} .\lambda x:\mathbb{N} .gm)I))d \rightarrow_{v} $}{$((\lambda g:\mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} .gn)(\lambda x:\mathbb{N} .Im))d$}}
                  \end{prooftree}


                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda g: \mathbb{N} \rightarrow \mathbb{N} . \lambda x: \mathbb{N} . gn)(\lambda x: \mathbb{N} . Im) \rightarrow_{v}  \lambda x: \mathbb{N} . (\lambda x: \mathbb{N} Im)n$}
                    \RL{$\texttt{CTX} _{(\bullet)d}$}
                    \UIC{\stackanchor{$((\lambda g:\mathbb{N} \rightarrow \mathbb{N} . \lambda x:\mathbb{N} .gn)(\lambda x:\mathbb{N} .Im))d \rightarrow_{v} $}{$(\lambda x:\mathbb{N} .(\lambda x:\mathbb{N} .Im)n)d$}}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda x:\mathbb{N} .(\lambda x:\mathbb{N} .Im)n)d \rightarrow_{v} (\lambda x:\mathbb{N}. Im)n$}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$(\lambda x:\mathbb{N}. Im)n \rightarrow_{v} Im$}
                  \end{prooftree}

                  \begin{prooftree}
                    \AXC{}
                    \RL{$\beta$}
                    \UIC{$Im \equiv (\lambda x: \mathbb{N}. x)n \rightarrow_{v} m$}
                  \end{prooftree}

            \item an abstract \textit{stack} datatype can be defined as follows:

                  \begin{align*}
                    \texttt{pack } &\langle \texttt{Stack} , \langle s_{0}, \langle \texttt{push} , \langle \texttt{peek}, \texttt{pop}   \rangle  \rangle  \rangle  \rangle \\
                                   &\texttt{ as }  \\ &\exists \texttt{stack}. \texttt{stack} \times ( \mathbb{N} \rightarrow \texttt{stack} \rightarrow \texttt{stack} \times \\
                                   &( \texttt{stack} \rightarrow \mathbb{N} \rightarrow \mathbb{N}  \times \texttt{stack} \rightarrow \texttt{stack}  )   )
                  \end{align*}
                  \todo{Check type of ``pop''}

                  Where:

                  \begin{itemize}
                    \item $s_{0} = \lambda \alpha .\lambda f: \mathbb{N} \rightarrow \alpha \rightarrow \alpha . \lambda x: \alpha . x$
                    \item $\texttt{Stack } = \forall \alpha.( \mathbb{N} \rightarrow \alpha \rightarrow \alpha ) \rightarrow \alpha \rightarrow \alpha$
                          \item \texttt{push, peek} and \texttt{pop}   are defined the same as in the exam booklet, over (concrete) the \texttt{Stack} type.
                  \end{itemize}
          \end{enumerate}
  \end{enumerate}

\end{question}
\newpage
\begin{question}
\[
  Y = \lambda y. (\lambda f. t(\lambda z.ffz))(\lambda f.t(\lambda z.ffz))
\]
\begin{enumerate}[label= (\alph*)]
  \item
        The following ASG was generated using SPARTAN and the following code:
        \begin{minted}{text}
          LAMBDA(;t.APP(
   LAMBDA(; f.
     APP(t, LAMBDA(; z.
                    APP(APP(f,f),z))
        )
   ),
   LAMBDA(; f.
     APP(t, LAMBDA(; z.
                    APP(APP(f,f),z))
        )
   )
))
        \end{minted}

        \begin{center}
          \includegraphics[scale=0.6]{YASG.png}
        \end{center}
  \item
        \begin{enumerate}[label= (\roman*)]
          \item
               \[
                Y(\lambda f.\lambda x.0)1
                \]

                \begin{center}
                  \includegraphics[scale=0.5]{2bi.png}
                \end{center}

                Firstly, the ASG evaluate the LHS, finding values on either side of the first application, it performs a reduction, replacing $\lambda t.$ with $\lambda f.\lambda x.0$:

                \begin{center}
                  \includegraphics[scale=0.5]{2bi2.png}
                \end{center}

                It goes on to attempt to further evaluate the LHS, again finding two values either side of an application, the LH thunk is expanded attaching the RH value as its parameter:


                \begin{center}
                  \includegraphics[scale=0.6]{2bi3.png}
                \end{center}

                Next, the machine performs a rewrite of a shared reference of $\lambda f.\lambda x.0$:

                \begin{center}
                  \includegraphics[scale=0.6]{2bi4.png}
                \end{center}

                Again finding two values on the LHS application, a reduction is performed, stripping the outer $\lambda $ from $\lambda f.\lambda x.0$, discarding the $Y$ combinator:


                \begin{center}
                  \includegraphics[scale=0.6]{2bi5.png}
                \end{center}

                Finally, finding 2 values either side of our application the system removes the next $\lambda $, leaving just $0$, our final result from this computation:


                \begin{center}
                  \includegraphics[scale=0.6]{2bi6.png}
                \end{center}

          \item
                \[
                Y(\lambda f.\lambda x.f(x)*0)1
                \]

                This expression will diverge. This occurs as the second operand of the $*$ operator (1) is is never evaluated as our $Y$ combinator will infinitely expand over the first function argument $\lambda f.\lambda x.f(x)*0$

                After 91 steps of execution the ASG abstract machine will be in the following state:

                \begin{center}
                  \includegraphics[scale=0.4]{2bii.png}
                \end{center}

                Intuitively, you can see that the second operand (1) is being pushed up as the $Y$ combinator duplicates the operation and first operand (0) infinitely.

          \item
                If we were to swap our operands to form an expression:

                \[
                Y(\lambda f.\lambda x.0*f(x))1
                \]

                This would terminate, due to the nature of our $*$ \textit{shortcut} operator which does not need to evaluate a second argument in the case where the first operand is 0.

                After 26 steps of execution we reach the following state:

                \begin{center}
                  \includegraphics[scale=0.4]{2biii.png}
                \end{center}

                Here you can see that we have a state where we are attempting to evaluate $0*@$, with a traditional (eager) multiplication operator, we would find a value on the left and an expression on the right, forcing us to evaluate the RHS until we reach a value. However, our \textit{shortcut} operator allows us to instead skip this evaluate and return 0, eliminating the hang the Y combinator would otherwise cause. Our final result would be:

                \begin{center}
                  \includegraphics[scale=0.6]{2bi6.png}
                \end{center}

        \end{enumerate}
  \item

        \begin{enumerate}[label =(\roman*)]
          \item
                My answer to b)i) would not be affected. Nor would my answer to b)ii) as the cause of the infinite expansion was the first argument, not the second.

                For b)iii) however, our answer would change. The program would no longer terminate as when it reached the state shown above, where $*$ is applied to a value (0) and an expression (@), it would be forced to expand the RHS application and create a similar infinite expansion as in b)ii) due to the use of the $Y$ combinator without a terminating condition.


          \item
                Because of the fact $\forall x, x*0 = 0*x = 0$, both $Y(\lambda f.\lambda x.f(x)*0)1$ and $Y(\lambda f.\lambda x.0*f(x))1$ can be optimised to $0$.
                In the first case, $f(x) * 0$ can be replaced with $0$ where we let $f(x) = x$ in the above fact.
                In the second case, $0*f(x)$ can be replaced with $0$ where we let $f(x) = x$ in the above fact.

                \todo[inline]{is this a trick question, check notes on code optimisation}

          \item
                Yes $Y(\lambda f.\lambda x.0)1$ can be optimised to $0$. This is the case as the result of evaluating the expression is not dependant on either of the parameters $f$ or $x$.
        \end{enumerate}

\end{enumerate}


\end{question}

\begin{question}
  \begin{enumerate}[label= (\alph*)]
    \item
          \begin{enumerate}[label= (\roman*)]
            \item
                  $a$ is true whenever $b$ is true. This is an example of an invariant, (a subset of \textit{safety properties}) as it can only be verified by checking $b \rightarrow a$ in each state individually. It can be represented in LTL as:
                  \[
                  \Box (b \rightarrow a)
                  \]

            \item
                  $a$ and $b$ are simultaneously true only a finite number of times.

                  This is a \textit{liveness property} as only an infinite path could satisfy $\Box(a \wedge b)$ and given such a path, we could easily extend it with a single state which satisfied $\neg (a \wedge b)$ to satisfy this property. In LTL it can be represented as: \todo[inline]{Check}


                  \[
                  \neg \Box (a \wedge b)
                  \]

            \item
                  every $b$ is immediately followed by an $a$

                  This is an example of a \textit{safety property} as any violation of this property would have a state satisfying $b$ (immediately) followed by a state satisfying $\neg a$. Such a trace cannot be extended to satisfy the property. It can be written in LTL as:\todo[inline]{check wording}


                  \[
                  \Box ( b \rightarrow \bigcirc a )
                  \]

            \item
                  exactly one of $a$ or $b$ (but not both) is eventually true. This is a \textit{liveness property} as given a trace in which both $a$ and $b$ appear true at least once, no suffix can be added to extend the trace s.t. it satisfies this property.

                  \todo[inline]{check}
                  \[
                  (\Diamond a \vee \Diamond b) \wedge (a \rightarrow \Box \neg b) \wedge (b \rightarrow \Box \neg a)
                  \]

            \item
                  if $a$ ever becomes true, then it remains true forever, and this is immediately preceded by a state where $b$ was true.

                  This is a \textit{liveness property} as given a trace that violates this property such as $a,b$, the trace cannot be extended with any suffix s.t. the property now holds.

                  \[
                  ((b \wedge \bigcirc a ) \rightarrow \bigcirc \bigcirc \Box a) \vee \neg (\neg b \wedge \bigcirc a)
                  \]
                  \[
                  ((b \wedge \bigcirc a ) \rightarrow \bigcirc \bigcirc \Box a) \vee (b \vee \bigcirc \neg a)
                  \]



          \end{enumerate}
    \item
          The first stage of LTL model checking is to negate the LTL formula $\Psi = \Box(b \rightarrow \bigcirc a)$:

          \begin{align*}
            \neg \Psi &= \neg\Box(b \rightarrow \bigcirc a) \\
                &= \Diamond \neg( b \rightarrow \bigcirc a ) \\
                &= \Diamond \neg (\neg b \vee \bigcirc a)\\
                &= \Diamond ( b \wedge \bigcirc \neg a )
          \end{align*}

          Our negation makes syntactic sense in this case, to prove that \textit{``every $b$ is immedately followed by an $a$''} does not hold, one must find a trace whereby a $b$ is immediately followed by $\neg a$.

          We then construct an NFA, $\mathcal{A}_{\Psi}$ of this formula:

          \begin{center}
            \begin{tikzpicture}
              \node [lts,initial] (q0) {$q_{0}$};
              \node [lts,right of=q0] (q1) {$q_{1}$};
              \node [lts,right of=q1,accepting] (q2) {$q_{2}$};

              \draw (q0) edge[loop above] node {$\neg b$ } (q0);
              \draw (q0) edge[->,bend left] node[above] {$b$} (q1);
              \draw (q1) edge[->,bend left] node[above] {$a \wedge \neg b$} (q0);
              \draw (q1) edge[->,loop above] node[above] {$b$} (q1);
              \draw (q1) edge node[above] {$\neg a$} (q2);
            \end{tikzpicture}
          \end{center}


          We then take the product of the LTS given in the question and the NFA $\mathcal{A}_{\Psi}$, defined above, to produce:

          $\mathcal{A}_{\Psi} \otimes M$, where $M$ is the LTS given in the question:


          \begin{center}
            \begin{tikzpicture}
              \node [prod,initial] (s0q0) {$s_{0}q_{0}$};
              \node [prod, right of=s0q0] (s1q1) {$s_{1}q_{1}$};
              \node [prod, right of=s1q1] (s2q1) {$s_{2}q_{1}$};
              \node [prod,right of=s2q1, accepting, label=right:{$ \{ \texttt{accept}  \} $}] (s0q2) {$s_{0}q_{2}$};

              \draw (s0q0) edge (s1q1);
              \draw (s1q1) edge[bend left] (s2q1);
              \draw (s2q1) edge[bend left] (s1q1);
              \draw (s2q1) edge (s0q2);
            \end{tikzpicture}
          \end{center}
          \todo[inline]{check NFA prod}

          Above you can see that the product of the NFA and LTS has an \textit{accepting} state, meaning there exists a trace that satisfies the negation of the property, i.e. the property does not hold for all possible traces.


  \end{enumerate}
\end{question}

\vspace*{1cm}
\pagebreak[3]\fbox{%
  \begin{minipage}[c]{0.92\textwidth}
    \raggedright{}
    Statement of good academic conduct

    By submitting this assignment, I understand that I am agreeing to the
    following statement of good academic conduct.
    \begin{itemize}
      \item
            I confirm that this assignment is my own work and I have not worked
            with others in preparing this assignment.
      \item
            I confirm this assignment was written by me and is in my own words,
            except for any materials from published or other sources which are
            clearly indicated and acknowledged as such by appropriate referencing.
      \item
            I confirm that this work is not copied from any other person's work
            (published or unpublished), web site, book or other source, and has
            not previously been submitted for assessment either at the University
            of Birmingham or elsewhere.
      \item
            I confirm that I have not asked, or paid, others to prepare any part
            of this work for me.
      \item
            I confirm that I have read and understood the
            \href{https://intranet.birmingham.ac.uk/as/registry/policy/conduct/plagiarism/index.aspx}{University
              regulations on plagiarism}.
    \end{itemize}

  \end{minipage}%
}
\end{document}
